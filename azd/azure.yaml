name: tc-cloudgames-users-api
metadata:
  template: tc-cloudgames-users-api@1.0.0
  
services:
  users-api:
    project: ../src/Adapters/Inbound/TC.CloudGames.Users.Api
    language: dotnet
    host: containerapp
    
    # Docker configuration
    docker:
      path: ../src/Adapters/Inbound/TC.CloudGames.Users.Api/Dockerfile
      context: ../src/Adapters/Inbound/TC.CloudGames.Users.Api
      
    # Container App specific configuration
    options:
      containerapp:
        ingress:
          external: true
          targetPort: 8080
          transport: http
          allowInsecure: false
        secrets:
          - name: postgres-connection-string
            keyVaultUrl: https://{{ .Env.AZURE_KEY_VAULT_NAME }}.vault.azure.net/secrets/postgres-connection-string
          - name: redis-connection-string
            keyVaultUrl: https://{{ .Env.AZURE_KEY_VAULT_NAME }}.vault.azure.net/secrets/redis-connection-string
          - name: servicebus-connection-string
            keyVaultUrl: https://{{ .Env.AZURE_KEY_VAULT_NAME }}.vault.azure.net/secrets/servicebus-connection-string
        env:
          - name: DATABASE_CONNECTION_STRING
            secretRef: postgres-connection-string
          - name: REDIS_CONNECTION_STRING
            secretRef: redis-connection-string
          - name: SERVICEBUS_CONNECTION_STRING
            secretRef: servicebus-connection-string
          - name: ASPNETCORE_ENVIRONMENT
            value: Production
          - name: ASPNETCORE_URLS
            value: http://+:8080
        scale:
          minReplicas: 0
          maxReplicas: 10
          rules:
            - name: http-scale-rule
              http:
                concurrentRequests: 10
        resources:
          cpu: 0.25
          memory: 0.5Gi
        identity:
          type: SystemAssigned

# Infrastructure configuration
# AZD will create Container App using internal Bicep templates
# No need to version any infrastructure files - they're generated automatically
infra:
  provider: bicep
  path: ./infra

# Hooks for additional configuration
hooks:
  postdeploy:
    shell: sh
    run: |
      echo "üîß Configuring Container App post-deployment..."
      
      # Get Container App name (created by AZD)
      CONTAINER_APP_NAME=$(az containerapp list \
        --resource-group $AZURE_RESOURCE_GROUP \
        --query "[?contains(name, 'users-api')].name" -o tsv)
      
      echo "üìù Container App: $CONTAINER_APP_NAME"
      
      # Get the System Managed Identity principal ID
      PRINCIPAL_ID=$(az containerapp identity show \
        --name $CONTAINER_APP_NAME \
        --resource-group $AZURE_RESOURCE_GROUP \
        --query "principalId" -o tsv)
      
      echo "üÜî System MI Principal ID: $PRINCIPAL_ID"
      
      # Grant Key Vault Secrets User role to System MI (if not already granted)
      echo "üîê Ensuring Key Vault access..."
      az role assignment create \
        --assignee $PRINCIPAL_ID \
        --role "Key Vault Secrets User" \
        --scope "/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AZURE_RESOURCE_GROUP/providers/Microsoft.KeyVault/vaults/$AZURE_KEY_VAULT_NAME" \
        --query "id" -o tsv || echo "‚úÖ Key Vault role assignment already exists"
      
      # Grant ACR Pull role for container image access
      echo "üì¶ Ensuring ACR access..."
      az role assignment create \
        --assignee $PRINCIPAL_ID \
        --role "AcrPull" \
        --scope "/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AZURE_RESOURCE_GROUP/providers/Microsoft.ContainerRegistry/registries/$AZURE_CONTAINER_REGISTRY_NAME" \
        --query "id" -o tsv || echo "‚úÖ ACR role assignment already exists"
      
      echo "‚úÖ Post-deployment configuration completed!"
      echo "üîë Container App has System Managed Identity access to Key Vault and ACR"
      echo "üöÄ Application ready for production traffic!"
