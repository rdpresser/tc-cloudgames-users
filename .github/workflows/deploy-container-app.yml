name: üöÄ Deploy Container App

on:
  workflow_call:
    inputs:
      service-name:
        required: true
        type: string
      workspace-path:
        required: true
        type: string
      dockerfile-path:
        required: true
        type: string
      environment:
        required: true
        type: string
      acr-name:
        required: true
        type: string
    secrets:
      AZURE_CREDENTIALS:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      # Prepare the local workspace path (keeps behaviour consistent with your caller workflow)
      - name: üìÇ Prepare workspace
        run: mkdir -p ${{ inputs.workspace-path }}

      # Checkout the API repo at the provided workspace path
      - name: üì• Checkout API repository
        uses: actions/checkout@v4
        with:
          path: ${{ inputs.workspace-path }}

      # Checkout the shared common repository used by the solution
      - name: üì• Checkout shared common repository
        uses: actions/checkout@v4
        with:
          repository: rdpresser/tc-cloudgames-common
          path: tc-cloudgames-solution/shared/common
          token: ${{ secrets.GITHUB_TOKEN }}

      # Install .NET (keeps parity with your build pipeline)
      - name: ‚öôÔ∏è Setup .NET 9.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      # Login to Azure using the provided service principal credentials
      - name: üîê Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Prepare build variables: immutable image tag + "latest" tag.
      # We will deploy using the immutable tag (image-uri) to force a new revision.
      - name: üèóÔ∏è Prepare Build Variables
        id: build-vars
        run: |
          # generate an immutable tag (timestamp + short sha)
          IMAGE_TAG="$(date +%Y%m%d-%H%M%S)-$(echo ${{ github.sha }} | cut -c1-8)"
          IMAGE_URI="${{ inputs.acr-name }}.azurecr.io/${{ inputs.service-name }}:${IMAGE_TAG}"
          IMAGE_URI_LATEST="${{ inputs.acr-name }}.azurecr.io/${{ inputs.service-name }}:latest"

          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "image-uri-latest=$IMAGE_URI_LATEST" >> $GITHUB_OUTPUT

      # Login to ACR to be able to push images
      - name: üê≥ Login to Azure Container Registry
        run: az acr login --name ${{ inputs.acr-name }}

      - name: ‚öôÔ∏è Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Build and push both tags: immutable and latest.
      - name: üèóÔ∏è Build and Push Docker Image
        uses: docker/build-push-action@v5
        id: build-push
        with:
          context: ./tc-cloudgames-solution
          file: ./tc-cloudgames-solution/${{ inputs.dockerfile-path }}
          push: true
          tags: |
            ${{ steps.build-vars.outputs.image-uri }}
            ${{ steps.build-vars.outputs.image-uri-latest }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      # Wait for the immutable tag to appear in ACR before proceeding to deploy.
      # This avoids race conditions where 'az containerapp update' runs before the image is available.
      - name: üîé Wait for image tag in ACR
        run: |
          ACR_NAME="${{ inputs.acr-name }}"
          REPO="${{ inputs.service-name }}"
          IMAGE_TAG="${{ steps.build-vars.outputs.image-tag }}"

          echo "Waiting for tag '$IMAGE_TAG' to appear in ACR $ACR_NAME (repo: $REPO)..."
          found=0
          for i in $(seq 1 10); do
            if az acr repository show-tags --name "$ACR_NAME" --repository "$REPO" -o tsv | grep -q "^${IMAGE_TAG}$"; then
              echo "‚úÖ Found tag $IMAGE_TAG in ACR"
              found=1
              break
            fi
            echo "‚è≥ Tag not found yet (attempt $i/10). Sleeping 6s..."
            sleep 6
          done

          if [ "$found" -ne 1 ]; then
            echo "‚ö†Ô∏è Tag $IMAGE_TAG not found in ACR after retries. Listing recent tags for debugging:"
            az acr repository show-tags --name "$ACR_NAME" --repository "$REPO" --top 20 -o tsv || true
            exit 1
          fi

      # Deploy to Azure Container Apps using the immutable image tag (image-uri).
      # IMPORTANT: Using the immutable tag ensures Azure creates a new revision.
      - name: üöÄ Deploy to Azure Container App (immutable tag)
        id: deploy
        run: |
          # find the container app name and resource group for the service-name
          CONTAINER_APP_INFO=$(az containerapp list \
            --query "[?contains(name, '${{ inputs.service-name }}')].[name, resourceGroup]" -o tsv | head -1)

          if [ -z "$CONTAINER_APP_INFO" ]; then
            echo "‚ùå Could not find a Container App containing name '${{ inputs.service-name }}' - aborting."
            az containerapp list -o table
            exit 1
          fi

          CONTAINER_APP_NAME=$(echo "$CONTAINER_APP_INFO" | awk '{print $1}')
          RESOURCE_GROUP=$(echo "$CONTAINER_APP_INFO" | awk '{print $2}')
          IMAGE_TO_DEPLOY="${{ steps.build-vars.outputs.image-uri }}"  # immutable tag

          echo "üöÄ Updating $CONTAINER_APP_NAME in RG $RESOURCE_GROUP with image $IMAGE_TO_DEPLOY"

          # Update the container app image. Using the immutable tag forces a new revision.
          az containerapp update \
            --name "$CONTAINER_APP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --image "$IMAGE_TO_DEPLOY" \
            --output none

          # Get FQDN to return to caller
          APP_URL=$(az containerapp show \
            --name "$CONTAINER_APP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --query "properties.configuration.ingress.fqdn" -o tsv)

          echo "container-app-name=$CONTAINER_APP_NAME" >> $GITHUB_OUTPUT
          echo "container-app-url=https://$APP_URL" >> $GITHUB_OUTPUT

      # Perform a simple health check after deployment (3 attempts).
      - name: üß™ Health Check
        run: |
          HEALTH_URL="${{ steps.deploy.outputs.container-app-url }}/health"
          echo "Checking health endpoint: $HEALTH_URL"
          sleep 20
          for i in {1..3}; do
            if curl -fsS "$HEALTH_URL" > /dev/null 2>&1; then
              echo "‚úÖ Health check passed!"
              exit 0
            fi
            echo "‚è≥ Health check attempt $i failed, retrying..."
            sleep 15
          done
          echo "‚ùå Health check failed after 3 attempts"
          exit 1
